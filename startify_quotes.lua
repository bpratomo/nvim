local quotes = {
    { "Effective Java 1. Create & destroy objects : Use STATIC FACTORY METHODS instead of constructors" },
    { "Effective Java 2. Create & destroy objects : Use BUILDERS when faced with many constructors" },
    { "Effective Java 3. Create & destroy objects : Enforce the singleton property with a private constructor or an enum type" },
    { "Effective Java 4. Create & destroy objects : Enforce noninstantiability with a private constructor" },
    { "Effective Java 5. Create & destroy objects : Avoid creating objects" },
    { "Effective Java 6. Create & destroy objects : Eliminate obsolete object references" },
    { "Effective Java 7. Create & destroy objects : Avoid finalizers" },
    { "Effective Java 8. Methods common to all objects: Obey the general contract when overriding *equals*" },
    { "Effective Java 9. Methods common to all objects: Always override _hashCode_ when you override *equals*" },
    { "Effective Java 10.Methods common to all objects:  Always override _toString_" },
    { "Effective Java 11.Methods common to all objects:  Override _clone_ judiciously" },
    { "Effective Java 12.Methods common to all objects:  Consider implementing _Comparable_" },
    { "Effective Java 13. Classes and Interfaces: Minimize the accessibility of classes and members" },
    { "Effective Java 14. Classes and Interfaces: In public classes, use accessor methods, not public fields" },
    { "Effective Java 15. Classes and Interfaces: Minimize Mutability" },
    { "Effective Java 16. Classes and Interfaces: Favor composition over inheritance" },
    { "Effective Java 17. Classes and Interfaces: Design and document for inheritance or else prohibit it." },
    { "Effective Java 18. Classes and Interfaces: Prefer interfaces to abstract classes" },
    { "Effective Java 19. Classes and Interfaces: Use interfaces only to define types" },
    { "Effective Java 20. Classes and Interfaces: Prefer class hierarchies to tagged classes" },
    { "Effective Java 21. Classes and Interfaces: Use function objects to represent strategies" },
    { "Effective Java 22. Classes and Interfaces: Favor static member classes over nonstatic" },
    { "Effective Java 23. Generics: Don't use raw types in new code" },
    { "Effective Java 24. Generics: Eliminate unchecked warnings" },
    { "Effective Java 25. Generics: Prefer lists to arrays" },
    { "Effective Java 26. Generics: Favor generic types" },
    { "Effective Java 27. Generics: Favor generic Methods" },
    { "Effective Java 28. Generics: Use bounded wildcards to increase API flexibility" },
    { "Effective Java 29. Generics: Consider _typesafe heterogeneous containers_" },
    { "Effective Java 30. Enums and Annotations: Use enums instead of _int_ constants" },
    { "Effective Java 31. Enums and Annotations: Use instance fields instead of ordinals" },
    { "Effective Java 32. Enums and Annotations: Use EnumSet instead of bit fields" },
    { "Effective Java 33. Enums and Annotations: Use EnumMap instead of ordinal indexing" },
    { "Effective Java 34. Enums and Annotations: Emulate extensible enums with interfaces" },
    { "Effective Java 35. Enums and Annotations: Prefer annotations to naming patterns" },
    { "Effective Java 36. Enums and Annotations: Consistently use the _Override_ annotation" },
    { "Effective Java 37. Enums and Annotations: Use marker interfaces to define types" },
    { "Effective Java 38. Methods: Check parameters for validity" },
    { "Effective Java 39. Methods: Make defensive copies when needed." },
    { "Effective Java 40. Methods: Design method signatures carefully" },
    { "Effective Java 41. Methods: Use overloading judiciously" },
    { "Effective Java 42. Methods: Use varargs judiciously" },
    { "Effective Java 43. Methods: Return empty arrays or collections, not nulls" },
    { "Effective Java 44. Methods: Write _doc comments_ for all exposed API elements" },
    { "Effective Java 45. General Programming : Minimize the scope of local variables." },
    { "Effective Java 46. General Programming : Prefer for-each loops to traditional for loops." },
    { "Effective Java 47. General Programming : Know and use libraries" },
    { "Effective Java 48. General Programming : Avoid float and double if exact answer are required" },
    { "Effective Java 49. General Programming : Prefer primitive types to boxed primitives" },
    { "Effective Java 50. General Programming : Avoid Strings where other types are more appropriate" },
    { "Effective Java 51. General Programming : Beware the performance of string concatenation" },
    { "Effective Java 52. General Programming : Refer to objects by their interface" },
    { "Effective Java 53. General Programming : Prefer interfaces to reflection" },
    { "Effective Java 54. General Programming : Use native methods judiciously" },
    { "Effective Java 55. General Programming : Optimize judiciously" },
    { "Effective Java 56. General Programming : Adhere to generally accepted naming conventions" },
    { "Effective Java 57. Exceptions: Use exceptions only for exceptional conditions" },
    { "Effective Java 58. Exceptions: Use checked exceptions for recoverable conditions and runtime exceptions for programming errors" },
    { "Effective Java 59. Exceptions: Avoid unnecessary use of checked exceptions" },
    { "Effective Java 60. Exceptions: Favor the use of standard exceptions" },
    { "Effective Java 61. Exceptions: Throw exceptions appropriate to the abstraction" },
    { "Effective Java 62. Exceptions: Document all exceptions thrown by each method" },
    { "Effective Java 63. Exceptions: Include failure-capture information in detail messages" },
    { "Effective Java 64. Exceptions: Strive for failure atomicity" },
    { "Effective Java 65. Exceptions: Don't ignore exceptions" },
    { "Effective Java 10. Exceptions: CONCURRENCY" },
    { "Effective Java 66. Exceptions: Synchronize access to shared mutable data" },
    { "Effective Java 67. Exceptions: Avoid excessive synchronization" },
    { "Effective Java 68. Exceptions: Prefer executors and tasks to threads" },
    { "Effective Java 69. Exceptions: Prefer concurrency utilities to _wait_ and _notify_" },
    { "Effective Java 70. Exceptions: Document thread safety" },
    { "Effective Java 71. Exceptions: Use lazy initialization judiciously" },
    { "Effective Java 72. Exceptions: Don't depend on thread scheduler" },
    { "Effective Java 73. Exceptions: Avoid thread groups" },
    { "Effective Java 74. Serialization: Implement _Serializable_ judiciously" },
    { "Effective Java 75. Serialization: Consider using a custom serialized form" },
    { "Effective Java 76. Serialization: Write _readObject_ methods defensively" },
    { "Effective Java 77. Serialization: For instance control, prefer _enum_ types to _readResolve_" },
    { "Effective Java 78. Serialization: Consider serialization proxies instead of serialized instances" },
}

return quotes
